# Nertworking


## Pod Internal Connection

For pod internal connection when containers are in the same pod, kubernetes allows to comminicate with each other via localhost.

I have two applications which will be in different containers but the same pod. For all containers I just need one deploymant and service .yaml files. 

For `deployment.yaml` I can add all containers under the `containers` option. Because `template` means the pod of the Deployment and under `template` option we can add all containers which will take a part in the pod.

- `deployment.yaml`
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: users-deployment
spec:
  replicas: 1
  selector: 
    matchLabels:
      app: users
  template:
    metadata:
      labels:
        app: users
    spec:
    # Same pod different pod you can add differen container here.
      containers:
        - name: users
          image: aylincelik/kub-network-users:2
          # I can access auth api via below address in my code
          env:
            - name: AUTH_ADDRESS
              value: localhost
        - name: auth
          image: aylincelik/kub-network-auth

```

For the auth api I dont expose it via any services because it should not be reachable from outside world, users application will reach it out from inside of the pod. So I just need a service for users deployment.

- Here is the `service.yaml`
```
apiVersion: v1
kind: Service
metadata:
  name: users-service
spec:
  selector:
    app: users
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
```

- Apply all configuration via below command
```
kubectl apply -f deployment.yaml -f service.yaml
```

## Pod-to-Pod Connection

You can use different ways as below.
- Cluster-Ip of the service. You can use below command for getting it.

```
kubectl get services
```
- Auto-generated by kubernetes. You dont need to define it anywhere, you can just use it where do you need. At my example it would be `AUTH_SERVICE_SERVICE_HOST`.

- CoreDNS (Domain Name Service). Core DNS is automatically generated by kubernetes and It creats domains which are known inside of the the cluster. You can use it like `"SERVICE_NAME.NAMESPACE_NAME"`. In my example value of the `AUTH_ADDRESS` env variable would be `"auth-service.default"`

Here are some example files which connect with each via different pods.

* `user-deployment.yaml`
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: users-deployment
spec:
  replicas: 1
  selector: 
    matchLabels:
      app: users
  template:
    metadata:
      labels:
        app: users
    spec:
      containers:
        - name: users
          image: aylincelik/kub-network-users:2
          env:
            - name: AUTH_ADDRESS
              #First approach
              #value: "10.104.124.239"
              
              #Third approach 
              #"SERVICE_NAME.NAMESPACE_NAME"
              value: "auth-service.default" 
```

* `users-service.yaml`

```
apiVersion: v1
kind: Service
metadata:
  name: users-service
spec:
  selector:
    app: users
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
```

- `auth-deployment.yaml`

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-deployment
spec:
  replicas: 1
  selector: 
    matchLabels:
      app: auth
  template:
    metadata:
      labels:
        app: auth
    spec:
      containers:
        - name: auth
          image: aylincelik/kub-network-auth
```

- `auth-service.yaml`
```
apiVersion: v1
kind: Service
metadata:
  name: auth-service
spec:
  selector:
    app: auth
  # It means it will not be reachable from outside world.
  type: ClusterIP
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
```

- Apply all configuration via below command
```
kubectl apply -f users-deployment.yaml -f users-service.yaml -f auth-deployment.yaml -f auth-service.yaml
```
